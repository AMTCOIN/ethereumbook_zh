[[私钥_地址]]
== 私钥, 地址


((("密码学", "定义")))((("密码学", 参考="私钥与地址")))以太坊的基础技术之一就是密码学;密码学是数学的一个分支，广泛用于计算机安全领域。密码学在希腊文中表示为“秘密书写”， 但是密码学背后的科学包含了“加密”这种远比“秘密书写”内涵丰富的知识。密码学也可以通过不泄漏加密文件（数字签名）的手段来验证加密内容；或者验证数据的真实性 (数字指纹). 这几种密码学公理不仅是以太坊，同时也是很多种区块链系统以及基于以太坊应用的最为重要的数学工具 ((("加密")))((("加密", 参考="密钥与地址")))讽刺的是，加密其实并不是以太坊最重要的部分，因为以太坊的通信以及交易数据没有加密，并且也不需要加密就可以维护系统的安全。这章我将介绍以太坊中用来控制资产主权的两个概念：私钥以及地址。


=== 介绍


以太坊有两种账户，一种用于拥有以太，另一种用来控制以太，这两种账号分别为：外部拥有账户(EOA)以及协议。在这部分我将研究如何通过密码学中的外部拥有账户，例如私钥，来建立以太的所有权。


((("数字签名", 参考="私钥与地址")))((("数字签名", "目的")))外部拥有账户（EOA）中的以太所有权是通过数字秘钥，以太坊地址以及数字签名建立的。数字秘钥并没有被存储到区块链内也并没有在以太坊网络上进行传输，而是由用户创建并存储在一个文件或被称为钱包的简单数据库中。钱包中用户的数字私钥是完全独立于以太坊协议中的，并且这个私钥可以在完全与区块链或者互联网隔绝的情况下通过用户的钱包软件产生或者管理。数字签名使以太坊的很多例如去中心化信任与控制以及所有权验证等特点成为可能。


以太坊交易需要将一个有效的数字签名包含在区块链中，这个数字签名可以通过私钥生成；因此，任何人只要拥有了这个私钥，就拥有了以太的所有权。以太坊交易中的数字签名证明了资产的真正所有者。


((("公钥以及私钥", "两种秘钥")))((("公钥与私钥", 参考="私钥与地址")))数字秘钥成对出现，包含一个私（秘）钥以及一个公钥。可以将公钥看作是银行账户的账号，私钥看作是银行账户的中提供银行账户控制权的密码。这些数字秘钥是以太坊使用者很少看到的。大部分情况下，这些秘钥都是存储到钱包文件中并且通过以太坊钱包管理的。


在一个以太坊交易过程中的付款部分，交易的目标收款方通过以太坊地址表示，类似于支票上填写的受益人名称（即‘以某人的名义付给’）。很多情况下， 以太坊地址由公钥产生，并关联于公钥。但是，并不是所有的以太坊地址代表公钥；他们也可以代表我们在<<合约>>部分即将看到的合约。以太坊地址是用户们常见的唯一密钥表示，因为这是用户们与世界分享的一部分。


首先，我们将介绍密码学并解释我们在以太坊中使用到的数学，其次，我们将会阐述密钥是如何生成，存储以及管理的。最后我们将回顾用于表示私钥，公钥以及地址的多种编码格式。
[[pkc]]

==== 公钥密码学以及加密货币

((("秘钥与地址", "概述", "公钥加密")))((("数字货币", "加密货币")))公钥密码学发明与19世纪70年代，是计算机以及信息安全的数学基础。


当代密码学更多的是基于拥有同一个独特特点的数学函数：从一个方向计算非常简单但是从相反方向计算却非常难。基于以上数学函数，密码学使得数字秘密的产生以及使得不可丢失的数字签名成为可能。


例如， 将两个很大的质数相乘不是难事。但是给出两个很大的质数相乘的结果，我们很难求出这两个质数（一个被称为质数数分解的问题）。假设我提出一个数为6895601，我告诉你这个数由两个质数相乘所得。求出这两个质数远比将两个质数相乘得到6895601困难得多。


如果给予你一个秘密信息，上面所说的一些问题将不难解决。比如说上面我们讨论的例子，如果我告诉你两个质数中的一个为1931， 你可以很轻松的找出与之相乘得6895601的另一个质数：6895601 / 1931 = 3571。 这类函数被称为陷门函数，因为给出秘密信息中的一部分，你可以找到一条捷径来将问题化简为一个很简单的问题。



另外一类在密码学中用处很广的数学函数基于椭圆曲线上的算术运算。在椭圆曲线上，相乘模块乘以素数是较为简单的，但是除法是不可能的（一个被称为离散对数的问题）。椭圆曲线密码学被广泛用于当代计算机系统，并且是以太坊（以及其他虚拟货币）数字密钥以及数字签名的基础。

[TIP]
====
阅读更多关于密码学以及现代密码学中的数学函数：

密码学:
https://en.wikipedia.org/wiki/Cryptography

陷门函数:
https://en.wikipedia.org/wiki/Trapdoor_function

质数分解:
https://en.wikipedia.org/wiki/Integer_factorization

离散对数:
https://en.wikipedia.org/wiki/Discrete_logarithm

椭圆曲线加密:
https://en.wikipedia.org/wiki/Elliptic_curve_cryptography
====


以太坊中，我们使用公钥加密来创作一对秘钥，通过这对秘钥我们可以访问以太或者验证合同。这对秘钥由一个私钥和一个由此得来的独一无二的公钥构成。这个公钥用来收取资金，私钥用来制作数字签名以便签署一个交易来使用资产。数字签名同时也被用来验证所有者或者合约的使用者，我们将会在<<合约验证>>部分详细了解。


公钥和私钥之间有着一种数学关系，这种数学关系可以使得私钥生成信息上的签名。该签名可以在不公开私钥的情况下验证其真实性。

使用以太的时候，当前的拥有者在每一笔交易中展示她的公钥以及签名（每一次都不一样，但是由同一个私钥产生）。在公钥以及签名的展示过程中，以太坊系统内的所有人都可以独自验证并接受交易的有效性，确认交易以太的人在交易过程中为这些以太的拥有者。

[TIP]
====
((("秘钥与地址", "概述", "秘钥对")))在绝大部分钱包软件中，私钥以及公钥为了方便共同存储为密钥对。但是，公钥可以通过私钥很简单的推导出，所以只存储私钥也是可行的。
====

.为什么使用非对称加密（公/私钥）？
****
((("加密", "对称")))((("数字签名", "对称加密与")))((("对称加密")))为什么在以太坊中使用非对称加密？对称加密并不用来“加密”某笔交易。非对称加密有用的特性是能够生成数字签名。一个私钥可以应用于一笔交易中的数字指纹来生成一个数字签名。这个签名只能由拥有私钥的人生成。然而，任何能够访问公钥以及交易指纹的人都可以使用它们来验证签名。非对称加密的这个特性使得任何人都能够验证任意一笔交易中的签名，同时可以确保只有私钥的拥有者才能生成有效签名。
****

[[private_keys]]
==== 私钥


((("密钥与地址", "概述", "生成私钥")))((("警告与注意事项", "私钥保护")))一个私钥就是一串随机挑选数字。对私钥的拥有权和控制权是用户控制某个以太坊地址资金的基础，也是访问授权该地址的合同的基础。通过证明在交易过程中用到的资产的所有权，私钥可以用来生成在使用以太过程中需要用到的签名。私钥在任何时刻都要保密，因为向第三方透露私钥就等于给予对方对这些以太资产以及合约的所有权。私钥必须备份并且一定要妥善保管，因为如果将私钥丢失就不能被找回，并且与之关联的所有资产都会永久丢失。
[TIP]
====
以太坊的私钥只是一串数字。你可以通过任何方式随机生成你的私钥，例如硬币，铅笔以及纸：投掷一枚硬币２５６次之后你就拥有了一串可以在以太坊钱包中使用的２５６位的随机生成的二进制数字。公钥以及地址之后可以通过私钥产生。
====

===== 通过随机数生成私钥

生成秘钥的第一步，也是最重要的一步就是寻找一个安全的熵或者随机性的来源。生成一个以太坊的私钥等价于从１到2^256挑选数字。挑选数字的方法并不重要，只要方法是不可预测的并且不是重复的。以太坊软件使用的是底层操作系统的随机数生成器来生成２５６比特的熵（随机性）。通常来说，操作系统的随机数生成器由人初始化，这就是为什么你会被要求晃动几秒钟你的鼠标或者按一些键盘上的随机键位。

更准确的来说，可用的私钥会稍微比2^256少。私钥可以是+1+ and +n - 1+　中的任何一个数，其中ｎ是一个常数（n = 1.158 * 10^77^,稍微小于　2^256^）定义为以太坊中椭圆曲线的阶数（参考<<椭圆曲线>>）。为了生成一个秘钥，我们随机挑选一个２５６比特的数字并且检查这个数字是否小于n-1。在编程方面，这通常是通过提供一大串随机位，从一个密码安全的随机源，转换到一个２５６位的例如Keccak-256或者SHA256算法里（参考<<加密哈希算法>>），这种方式可以产生一个256比特的数字。如果结果小于n-1，我们就得到了一个合适的私钥。否则，我们只需再次尝试使用另一个随机数。


[警告]
====
((("随机数", "随机数生成器")))((("熵", "生成随机数")))
不要自己尝试实现一个随机数生成器，也不要使用一个某种编程语言提供的"简单"的随机数生成器（CSPRNG）。使用从具有高熵的信息源生成的种子并且使用密码学上安全的伪随机数生成器（CSPRNG）。使用随机数生成器前要阅读此生成器的文档来判断它是否密码学上足够安全。正确的CSPRNG是对保证秘钥的安全性很重要。
====

下面所示为一个以十六进制表示的随机生成的私钥（２５６比特用６４位１６进制数表示，每４个比特表示一个１６进制数）：

----
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----


[贴士]
====
以太坊的私钥可能性空间（2^256^）是一个深不可测的数字。用十进制表示大约有10^77^种可能。与之比较的话，可见宇宙中大约包含10^80^原子。
====


[[公钥]]
==== 公钥

((("秘钥与地址", "综述", "公钥计算")))((("生成器点")))
以太坊公钥是椭圆曲线上的一个点，意味着它是一组满足椭圆曲线方程的X和Y坐标。

简单来说，以太坊的公钥由两个数组成的。这些数由私钥通过一个只能单向的计算得出。这意味着由私钥计算公钥是很简单的，但是不能从公钥计算私钥。

[[警告]]
====
接下来会有数学部分！别担心。如果你觉得上述部分很难理解，那么你可以跳过接下来的几部分。有很多工具以及库可以帮你处理这些数学部分的内容。
====

公钥通过私钥使用椭圆曲线相乘来计算得出，这个过程是不可逆的：K = k * G, 其中ｋ是私钥，G是一个称为生成点的常数点，ｋ是对应生成的公钥。这个被称为“搜寻离散对数”的逆运算，难度堪比找出所有k的可能取值，也就是暴力搜索。　

用更简单的话来说：椭圆曲线上的代数计算与"普通的“整数代数不同。一个点（Ｇ）可以与一个整数（ｋ）相乘得出另一个数（ｋ）。但是这个过程中不存在相除，所以不可能直接用点Ｇ除公钥Ｋ来得到私钥ｋ。这是一个单向数学方程，在<<pkc>>部分会继续描述。

[TIP]
====

椭圆曲线乘法是密码学家们称为"单向"方程的一类方程：从一个方向（相乘）很简单，但是从反方向（相除）却不可能。私钥的所有者可以轻松地生成公钥然后与世界分享，因为大家知道没有人可以将方程反向来通过公钥计算私钥。这种数学技巧成为证明以太坊资金所有权和合同控制权不可伪造的基础，也是保障数字签名安全的基础。

====

在我们展示如何从私钥生成公钥之前，我们先来更细节的了解一下椭圆曲线加密。


[[椭圆曲线]]
==== 解释椭圆曲线加密

((("秘钥与地址", "概述", "椭圆曲线加密")))((("椭圆曲线加密", id="eliptic04")))((("加密", "椭圆曲线加密", id="Celliptic04")))
椭圆曲线加密是一类对称且基于离散对数问题的公钥密码学，这个问题由椭圆曲线上点的相加以及相乘表示。

<<ecc-曲线>> 是椭圆曲线的一个例子，与以太坊中使用的椭圆曲线很像。

[TIP]
====
以太坊使用与比特币完全一样的椭圆曲线，称为secp256k1。这代表比特币中很多椭圆曲线的库都可以被我们重复运用。
====

[[ecc-曲线]]
[role="smallerthirty"]
.椭圆曲线的可视化
image::images/simple_elliptic_curve.png["ecc-curve"]

以太坊使用的特定椭圆曲线以及数学常数在一个称为secp256k1的标准中定义，这个标准由国际标准技术机构建立(NIST).secp256k1曲线由下面的方程定义。

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

或

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

_mod p_（质数ｐ模）表明该曲线位于ｐ阶素数的有限域上，也可以写为　latexmath:[\( \mathbb{F}_p \)], 其中 p = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1,这是一个非常大的质数。

因为这条曲线是在素数阶的有限域上而不是在实数域定义的，所以它看起来像是分散在两个维度上的散点图，使得我们很难观察。 然而，两者数学原理是相同的，散点图与与实数上的椭圆曲线是相同的。比如说，在F（p）上可视化一个椭圆曲线，p = 17在一个更小的素数阶17的有限域上显示了相同的椭圆曲线，在网格上显示了一个点的模式。secp256k1以太坊椭圆曲线可以被认为是一个在更大的网格区域内的更加复杂的点的模式。

[[ecc-over-F17-math]]
[role="smallersixty"]
.椭圆曲线密码学: 可视化F（p）上的椭圆曲线，其中p = 17
image::images/ec_over_small_prime_field.png["ecc-over-F17-math"]

那么，比如说，以下是坐标为（x，y）的某点Q，它是secp256k1曲线上的点：

----
Q = (49790390825249384486033144355916864607616083520101638681403973749255924539515, 59574132161899900045862086493921015780032175291755807399284007721050341297360)
----

<<example_1>>展示了如何使用Python自己尝试。 变量x和y是上述点Q的坐标。 变量p是椭圆曲线的质数阶数（用于所有取模运算的素数）。 Python的最后一行是椭圆曲线方程（Python中的％运算符是取模运算符）。 如果x和y确实是椭圆曲线上的点，那么它们一定满足方程，结果一定为零（+ 0L +是值为零的长整数）。在命令行上输入+python+并复制下面列表中的每一行(+>>>+后面的内容)自己尝试一下吧。

[[example_1]]
.使用ｐｙｔｈｏｎ证实点在椭圆曲线上
====
[source, pycon]
----
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
>>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
>>> (x ** 3 + 7 - y**2) % p
0L
----
====

[[ec_math]]
==== 椭圆曲线算术运算

很多椭圆曲线数学看起来很像我们在学校学到的整数算术。具体而言，我们可以定义一个加法运算符，而不是在曲线上添加数字。一旦有了加法运算符，我们也可以定义一个点和一个整数的乘法，这样它就等于重复加法。

加法被定义为若给定两点P 1、P 2都在椭圆曲线上，则在椭圆曲线上也存在第三点P 3 = P 1 + P 2。

在几何上，通过在P 1和P 2之间划一条线来计算该第三点P 3。这条线将在另外一个地方与椭圆曲线相交。称此点P 3 '=（x，y）。然后在x轴上反射以得到P 3 =（x，-y）。

在椭圆曲线数学中，有一个叫做无限点的点，它大致对应于零点的作用。在计算机上，它有时用x = y = 0表示这并不满足椭圆曲线方程，但它是一个可被检验且简单的独立例子。有一些特殊的例子解释了“无限点”的必要性。

如果P 1和P 2是相同的点，则在P 1和P 2之间的线应当延伸成在该点P 1处的曲线上的切线。该切线恰好与一条新点中的曲线相交。您可以使用微积分技术来确定切线的斜率。尽管我们将我们的兴趣集中在具有两个整数坐标的曲线上，但这些技巧仍然令人好奇地工作！

在某些情况下（即如果P 1和P 2具有相同的x值但不同的y值），切线将完全垂直，在这种情况下，P3 =“无限点”。

如果P 1是“无穷远点”（“无限点”），则P 1 + P 2 = P 2。类似地，如果P 2是无限点，则P 1 + P 2 = P 1。这显示了无限点如何扮演在“正常”算术中的角色。

事实证明+是关联的，这意味着（A + B）+ C = A +（B + C）。这表明我们可以在没有括号的情况下写出A + B + C而没有歧义。

现在我们已经定义了加法，乘法也可以用扩展加法的标准方式来定义。对于椭圆曲线上的点P，如果k是整数，则k * P = P + P + P + ... + P（k次）。请注意，在这种情况下，k有时会被混淆地称为“指数”

[[public_key_derivation]]
==== 生成公钥

从一个随机生成的数字形式的私有密钥ķ开始，我们把它乘以曲线上被称为发生器点 G的预定点，以在曲线上的其他位置产生另一个点，这是相应的公钥K。发生器点被指定为secp256k1标准的一部分，并且对于secp256k1的所有实现都是相同的，所有从该曲线派生出的密钥都使用相同的点G：

[latexmath]
++++
\begin{equation}
{K = k * G}
\end{equation}
++++

其中k是私钥，G是生成器点，K是结果公钥，即曲线上的一个点。因为所有以太坊用户的生成点始终相同，所以一个乘以G的私钥总是得到相同的公钥K. k和K之间的关系是固定的，但只能按照从k到K一个方向计算。这就是为什么以太坊地址（从K派生）可以与任何人共享，且不会泄露用户的私钥（k）.

正如我们在椭圆曲线算术运算中所描述的那样，k * G的乘法相当于重复加法，所以G + G + G + ... + G重复k次。总之，为了从私钥k产生公钥K，我们将发生器点G自身相加k次。

[提示]
====
私钥可以转换为公钥，但公钥不能转换回私钥，因为此处只能单向运算。
====

让我们运用该计算来找到我们在私钥中给出的特定私钥的公钥：


[[example_privkey]]
私钥运算产生公钥示例
----
K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G
----

密码库可以帮助我们使用椭圆曲线乘法计算K值。得到的公钥K被定义为点K =（x，y）：

[[example_pubkey]]
.从示例私钥计算的示例公钥
----
K = (x, y)
这里,
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

在以太坊中，您可以看到公钥以66个十六进制字符（33字节）的十六进制序列表示。这采用了行业联盟标准高效密码组（SECG）提出的标准序列化格式，记录在高效密码标准（SEC1）中。该标准定义了四个可用于识别椭圆曲线上点的可能前缀：

|===
| 字首 | 含义 | 长度（字节计数前缀） |
|0x00| 指向无限 | 1 |
|0x04| 未压缩的点 | 65 |
|0x02| 接近Y的压缩点 | 33 |
|0x03| 奇数Y的压缩点 | 33 |
|===

以太坊只使用未压缩的公钥，因此唯一相关的前缀是（十六进制）04。序列化连接公钥的X和Y坐标：

----
04 + X坐标（32字节/ 64十六进制）+ Y坐标（32字节/ 64十六进制）
----

因此，我们在示例私钥计算的示例公钥中计算的公钥被序列化为：

----
046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

==== 椭圆曲线库

加密货币相关项目中使用了secp256k1椭圆曲线的几个实现：

((("OpenSSL cryptographic library")))OpenSSL:: TOpenSSL库提供了一套全面的加密原语，包括secp256k1的完整实现。例如，要派生公钥，可以使用函数EC_POINT_mul（）. 在这里可以找到https://www.openssl.org/

((("libsecp256k1 cryptographic library")))libsecp256k1:: Bitcoin Core的libsecp256k1是secp256k1椭圆曲线和其他加密基元的C语言实现。椭圆曲线密码学的libsecp256是用scratch编写的，代替了比特币核心软件中的OpenSSL，在性能和安全性方面被认为是优越的。在https://github.com/bitcoin-core/secp256k1找到它
((("libsecp256k1 cryptographic library")))libsecp256k1:: Bitcoin Core的libsecp256k1是secp256k1椭圆曲线和其他加密基元的C语言实现。椭圆曲线密码学的libsecp256是用scratch编写的，代替了比特币核心软件中的OpenSSL，在性能和安全性方面更为优越。在https://github.com/bitcoin-core/secp256k1找到它

[[hash_functions]]
=== 加密哈希函数

((("hash function")))密码哈希函数在整个以太坊使用。实际上，散列函数在几乎所有的密码系统中都有广泛的应用，这是密码学家布鲁斯•施奈尔（Bruce Schneier）所说的一个事实，他说：“相比加密算法，单向散列函数是现代密码学的主要工具。”

在本节中，我们将讨论散列函数，了解它们的基本属性以及这些属性如何使它们在现代密码学的很多领域广泛运用。我们在这里讨论哈希函数，因为它们是将以太坊公钥转换为地址的一部分。

简而言之，“散列函数是可用于将任意大小的数据映射到固定大小的数据的任意函数。” 来源：维基百科。散列函数的输入称为原象或消息。输出被称为散列或摘要。哈希函数的一个特殊子类别是加密哈希函数，它具有对密码学有用的特定属性。

密码散列函数是一种单向散列函数，它将任意大小的数据映射到固定大小的位串，如果知道输出，则在计算上不可能重新创建输入。确定输入的唯一方法是对可能的输入进行暴力搜索，检查匹配输出。

加密哈希函数有五个主要属性（来源：维基百科/加密哈希函数）：

确定性:: 任何输入消息总是产生相同的散列摘要。

可验证:: 计算消息的散列是有效的（线性性能）。

不可逆性（抵抗原象）:: 从哈希计算消息是不可行的，相当于通过可能的消息进行暴力搜索。

不相关:: 对消息的小改动（例如，一bit的改变）应该会全盘改变散列输出，以至于它不能与原始消息的散列相关联。

碰撞保护（抵抗原象）:: 计算产生相同散列输出的两个不同消息应该是不可行的。

这些属性的组合使加密散列函数可用于广泛的安全应用程序，包括：

* 数据指纹
* 消息完整性（错误检测）
* 工作内容验证
* 身份验证（密码散列和密钥扩展）
* 伪随机数发生器
* 预映像（原象）承诺
* 唯一标识符

当我们在以太坊中通过系统各个层面进行研究时，会发现以上多种属性。


==== 以太坊的加密哈希函数 - Keccak-256

((("SHA-3 Hash Function")))((("Keccak Hash Function")))((("Keccak-256")))以太坊在许多地方使用Keccak-256密码散列函数。Keccak-256被设为国家科学和技术研究院（NIST）于2007年举行的SHA-3密码散列函数竞赛的去掉人）。Keccak在2015年成为标准化为联邦信息处理标准（FIPS）202的获奖算法。

然而，在Ethereum开发期间，NIST标准化工作正在完成。在标准过程完成后，NIST调整了Keccak的一些参数，据称可以提高效率。在此期间，英雄举报者爱德华•斯诺登披露的文件暗示了NIST可能受到国家安全局的不当影响，故意削弱Dual_EC_DRBG随机数生成器标准，在标准随机数生成器中有效地设置后门。这场争论的结果是以太坊基金会决定实施由其发明人所提议的原来的Keccak算法，而不是经NIST修改的SHA-3标准

[警告]
====
虽然您可能在Ethereum文档和代码中看到“SHA3”，但很多（可能不是全部）这些实例实际上是指Keccak-256，而不是最终确定的FIPS-202 SHA-3标准。实现差异很小，与填充参数有关，但它们的重要性在于Keccak-256在给定相同输入的情况下产生与FIPS-202 SHA-3不同的散列输出。
====

由于以太坊（Keccak-256）中使用的散列函数与最终标准（FIP-202 SHA-3）之间的差异所导致的混乱，因此在所有代码、操作码和库中重命名所有sha3实例到keccak256的工作在努力进行中。详情请参阅ERC-59。

==== 我使用的是哪种散列函数

如何判断您使用的软件库是FIPS-202 SHA-3还是Keccak-256（如果两者都可能被称为“SHA3”）？

一个简单的方法是使用测试矢量，一个给定输入的预期输出。最常用于散列函数的测试是空输入。如果您使用空字符串作为输入运行散列函数，您应该看到以下结果：

[[sha3_test_vectors]]
.测试您使用的SHA3库是否是FIP-202 SHA-3的Keccak-256
----
Keccak-256("") =
c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
SHA-3("") =
a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
----

因此，无论调用什么函数，都可以通过运行上面的简单测试来测试它是否是原始的Keccak-256或最终的NIST标准FIPS-202 SHA-3。请记住，以太坊使用Keccak-256，尽管它在代码中通常被称为SHA-3。

接下来，我们来研究一下Ethereum中Keccak-256的第一个应用，它将从公钥生成以太坊地址。

=== 以太坊地址
以太坊地址是使用单向散列函数（特别是Keccak-256）从公钥或合约派生的唯一标识符。
在我们之前的例子中，我们从一个私钥开始，使用椭圆曲线乘法来派生一个公钥：
私钥k：
----
k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----

公钥K（X和Y坐标连接并显示为十六进制）：
----
K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

我们使用Keccak-256来计算这个公钥的哈希值：

----
Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

然后我们只保留最后的20个字节，这是我们的以太坊地址：

----
001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

大多数情况下，您会看到带有前缀“0x”的以太坊地址，表明它是十六进制编码，如下所示：

----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

=== 以太坊地址格式

以太坊地址是一串十六进制数字，通过计算公钥的Keccak-256哈希值取其最后20个字节作为地址。

比特币通过在客户端的用户界面中编码地址并包含内置校验和，以防止输入错误地址。与之不用的是，以太坊地址以原始十六进制形式呈现，没有经过任何校验和。

这其中的协议设计的理念是，以太坊地址最终会隐藏在系统高层的抽象（如命名服务）之后，并且必要时应在较高层添加校验和。

深思起来，这种设计选择会带来一些问题，包括由于输入错误地址和输入验证错误而导致的资金损失。 此外，以太坊命名服务的开发速度低于最初预期，再诸如ICAP之类的替代编码被钱包开发商采纳的进度也十分缓慢。


==== 互通客户端地址协议（ICAP）

_客户端地址互换协议（ICAP）_ 是一种与国际银行帐号（IBAN）编码部分兼容的以太坊地址编码，可以为以太坊地址提供多功能，校验和相互操作编码。 ICAP地址可以编码以太坊地址或通过以太坊名称注册表注册的常用名称。

详情可以参考以太坊Wiki上的ICAP原文：https://github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol

IBAN是识别银行账号的一种国际标准，主要应用于电汇。 它在单一欧元支付区（SEPA）中被广泛采用。 IBAN是一项集中且严格监管的服务。 对以太坊地址来说，ICAP可以实现以太坊地址的分散和兼容性。

一个IBAN由至多34个字母数字字符串（不区分大小写）组成，包括国家代码，校验和以及特定国家银行账户标识符的。

ICAP采用相同的结构，引入代表"Ethereum"的非标准国家代码"XE"，后面跟着两个字符的校验和以及3个可能的账户标识符变体：

直接型（Direct）:: 最多30个字母数字字符、big-endian或base-36整数组成，满足以太坊地址的最低有效位。 由于此编码适合小于155位，因此它仅适用于以一个或多个零字节开头的以太坊地址。 就字段长度和校验和而言，其优点是它能与IBAN兼容。 示例：+XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD+（33个字符长）

基本型（Basic）:: 除长度为31个字符外，与"直接型（Direct）"编码相同。 这使得它可以编码任何以太坊地址，却和IBAN字段验证并不兼容。 示例：+XE18CHDJBPLTBCJ03FE9 O2NS0BPOJVQCU2P+（35个字符长）

非直接型（Indirect）:: 编码一个标识符, 它通过名称注册表提供去解析以太坊地址。利用16个字母数字字符，其中包含资产标识符（例如ETH），名称服务（例如XREG）和9字符名称（例如KITTYCATS），这是一个人类可以直接阅读的名称。 示例：+XEpass:[##]ETHXREGKITTYCATS+（20个字符长），"##"代表两个计算校验和字符。


我们可以使用 +helpeth+ 命令行工具来创建ICAP地址。
以下为使用私钥示例（前缀为0x并作为参数传递给helpeth）：

----
$ helpeth keyDetails -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
Address: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
ICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D
Public key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

+helpeth+ 命令为我们构造了一个十六进制以太坊地址和一个ICAP地址。 我们示例密钥的ICAP地址是：

----
XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD
----

由于我们的示例的以太坊地址恰好以零字节开始，因此可以使用以满足IBAN格式的"直接型"ICAP编码方法进行编码。 你可以自行判断，因为它是33个字符长。

如果我们的地址不是从零开始，那么它将被编码为"基础型"编码，也就是35个字符长，同时作为IBAN格式是无效。

[小贴士]
====
以零字节开始的任何以太坊地址的概率是1：256. 要生成这样一个类型的地址，在找到一个作为IBAN兼容的"直接"编码ICAP地址之前，平均需要尝试256次生成256个不同的随机私钥。
====

因此，仅会有极少数的钱包支持ICAP。

==== 十六进制编码大小写字母的校验和（EIP-55）


由于ICAP或命名服务部署缓慢，采用以太坊改进建议-55（EIP-55）被提出。以下链接将提供详细信息：

https://github.com/Ethereum/EIPs/blob/master/EIPS/eip-55.md

通过修改十六进制地址的大小写，EIP-55为以太坊地址提供向后兼容的校验和。具体思路如下，以太坊地址不区分大小写，所有钱包都应该接受以大写字母或小写字母表示的以太坊地址，在解释上不存在任何区别。

通过修改地址中字母字符的大小写，我们可以传达一个校验和，用来保护地址的完整性，避免输入或读取错误。不支持EIP-55校验和的钱包粗略地忽略地址包含混合大写的事实。但那些支持EIP-55校验和的钱包可以验证，还能以99.986％的准确度检测存在的错误。

混合大写字母的编码变化很微妙，最初你甚至不会注意到它。 我们的示例地址是：

----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

通过EIP-55混合大写校验和，它变成：

----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

你能分辨出来吗？ 一些来自十六进制编码字母的字母（A-F）字符现在是大写字母，而另一些则是小写字母。 除非你仔细观察，否则你甚至不会注意到这种差异的存在。

EIP-55实施起来十分的简单。 我们采用小写十六进制地址的Keccak-256哈希。 这个哈希值作为该地址的数字指纹，为我们提供了一个便捷的校验和。 输入（地址）中的任何小改动都会导致哈希值结果（校验和）发生很大变动，从而使我们能够有效地检测存在的错误。 然后我们的地址的哈希值被编码为地址中的大写字母。 我们可以以一步步解析它：

1. 哈希小写地址，不带+0x+前缀：

----
Keccak-256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9")
23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1
----

[start=2]
1. 如果哈希值的相应十六进制数字大于或等于0x8，则将每个字母地址字符大写。 如果我们对地址和哈希进行排列，这将更容易显示：

----
Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

地址的第四个位置上是字母d。 哈希值的第四个字符是6，它小于8。所以，我们忽略小写字母d。 我们地址中的下一个字母字符是f，在第六位。 十六进制散列的第六个字符是c，它大于8。因此，我们在地址中大写了F，依此类推。 正如您所看到的，我们只使用哈希值的前20个字节（40个十六进制字符）作为校验和，因为我们只有20个字节（40个十六进制字符）能被相应地改为大写。

检查自己生成的混合大写地址，看看您是否可以判断出哪些字符，以及它们对应的哈希值中的字符：

----
Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

==== 检测EIP-55编码地址中的错误

现在，我们来看看EIP-55地址如何帮助我们发现错误。 假设我们已经打印出EIP-55编码的以太坊地址：

----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

现在，我们故意犯下一个阅读该地址时的基本错误。 最后一个字符之前的字符是大写字母"F"。 对于这个例子，我们假设我们误解为大写"E"。 我们在钱包中输入不正确的地址：

----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
----

幸运的是，我们的钱包符合EIP-55标准！ 它注意到混合大写字母进而尝试验证地址。 它将其转换为小写，并计算校验和哈希值：

----
Keccak-256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9")
5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927
----

正如你所看到的，尽管地址只改变了一个字符（事实上，只有一位"e"和"f"相隔了1字符间距），地址的哈希值却发生根本性的改变。 这就是哈希值函数的特性，使得它们对校验和非常有帮助！

现在，让我们排列这两个地址并检查大小写：

----
001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
5429b5d9460122fb4b11af9cb88b7bb76d892886...
----

这些都是错误的！其中的几个字母字符被错误地大写了。 现在请记住，大写字母是"正确"校验和的编码。

我们输入的地址大小写与刚刚计算的校验和不匹配，这就意味着地址中的内容发生了变化，并引入了一些错误。
