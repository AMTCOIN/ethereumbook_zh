[[私钥_地址]]
== 私钥, 地址


((("密码学", "定义")))((("密码学", 参考="私钥与地址")))Ethereum最基础的知识是_密码学_; 密码学是数学的一个分支，广泛用于计算机安全领域。密码学在希腊文中表示为“秘密书写”， 但是密码学背后的科学包含了“加密”这种远比“秘密书写”内涵丰富的知识。密码学可以通过不揭示秘密的手段来验证秘密里面的内容(数字签名)；或者验证数据的真实性 (数字指纹). 这几种密码学公理不仅是以太坊，同时也是很多种区块链系统以及基于以太坊应用的最为重要的数学工具 ((("加密")))((("加密", 参考="私钥与地址")))讽刺的是，加密其实并不是以太坊最重要的部分，因为以太坊的通信以及交易数据并没有加密也并不需要加密就可以维护系统的安全。这章我将介绍以太坊中用来控制资产主权的两个概念：私钥以及地址。


=== 介绍


以太坊有两种账户，一种用于拥有以太，另一种用来控制以太，这两种账号分别为：_外部拥有账户_(EOA) 以及 _协议_。 在这部分我将审视如何通过密码学中的外部拥有账户，例如私钥，来建立以太的所有权。


((("数字签名", 参考="私钥与地址")))((("数字签名", "目的")))外部拥有账户（EOA）中的以太所有权是通过_数字秘钥_，_以太坊地址_以及_数字签名_建立的。数字秘钥并没有被存储到区块链内也并没有在以太坊网络上进行传输，实际上，数字秘钥是用于自己生成并存储到一个名为_钱包_的文件或者简易数据库中的。钱包中用户的数字私钥是完全独立于以太坊协议中的，并且这个私钥可以在完全与区块链或者互联网隔绝的情况下通过用户的钱包软件产生或者管理。数字签名使以太坊的很多例如去中心化信任与控制以及所有权验证等特点成为可能。


以太坊交易需要将一个有效的数字签名包含在区块链中，这个数字签名可以通过私钥生成；因此，任何人只要拥有了这个私钥，就拥有了以太的所有权。以太坊交易中的数字签名证明了资产的真正所有者。


((("公钥以及私钥", "两种秘钥")))((("公钥与私钥", 参考="私钥与地址")))数字秘钥成对出现，包含一个私（秘）钥以及一个公钥。可以将公钥看作是银行账户的账号，私钥看作是银行账户的中提供银行账户控制权的密码、这些数字秘钥是以太坊使用者很少看到的。最重要的是，这些秘钥都是存储到钱包文件中并且通过以太坊钱包管理的。


在一个以太坊交易过程中的付款部分，交易的目标收款方通过_以太坊地址_表示，类似于支票上填写的受益人名称（即‘以某人的名义付给’）。很多情况下， 以太坊地址由公钥产生，并关联于公钥。但是，并不是所有的以太坊地址代表公钥；他们也可以代表我们在<<合约>>部分即将看到的合约。以太坊地址是用户们最常见的一种秘钥表示，因为这是用户们与世界分享的一部分。


首先，我们将介绍密码学并解释我们在以太坊中使用到的数学，其次，我们将会阐述秘钥是如何生成，存储以及管理的。最后我们将回顾表示私钥，公钥以及地址的多种编码格式。

[[pkc]]

==== 公钥密码学以及加密货币

((("秘钥与地址", "概述", "公钥加密")))((("数字货币", "加密货币")))公钥密码学发明与19世纪70年代，是计算机以及信息安全的数学基础。


当代密码学更多的是基于拥有同一个独特特点的数学函数：从一个方向计算非常简单但是从相反方向计算却非常难。基于以上数学函数，密码学使得数字秘密的产生以及不可丢失的数字签名成为可能。


例如， 将两个很大的质数相乘不是难事。但是给出两个很大的质数相乘的结果，我们很难求出这两个质数（一个被称为_指数分解_的问题）。或者我提出一个数为6895601，我告诉你这个数由两个质数得出。求出这两个质数远比将两个质数相乘得到6895601困难得多。


如果给予你一个秘密信息，上面所说的一些问题将不难解决。比如说上面我们讨论的例子，如果我告诉你两个质数中的一个为1931， 你可以很轻松的找出与之相乘得6895601的另一个质数：6895601 / 1931 = 3571。 这类函数被称为_暗门函数_，因为给出秘密信息中的一部分，你可以找到一条捷径来将问题化简为一个很简单的问题。


另外一类在密码学中用处很广的数学函数基于椭圆曲线上的算术运算。在椭圆曲线上，相乘模块乘以素数是较为简单的，但是除法是不可能的（一个被称为_离散对数问题_）。椭圆曲线密码学被广泛用于当代计算机系统，并且是以太坊（以及其他虚拟货币）数字秘钥以及数字签名的的基础。

[TIP]
====
阅读更多关于密码学以及现代密码学中的数学函数：

密码学:
https://en.wikipedia.org/wiki/Cryptography

后门函数:
https://en.wikipedia.org/wiki/Trapdoor_function

质数分解:
https://en.wikipedia.org/wiki/Integer_factorization

离散对数:
https://en.wikipedia.org/wiki/Discrete_logarithm

椭圆曲线加密:
https://en.wikipedia.org/wiki/Elliptic_curve_cryptography
====


以太坊中，我们使用公钥加密来创作一对秘钥，通过这对秘钥我们可以访问以太或者验证合同。这对秘钥由一个私钥和一个由此得来的独一无二的公钥构成。这个公钥用来收取资金，私钥用来制作数字签名以便签署一个交易来使用资产。数字签名同时也被用来验证所有者或者合约的使用者，我们将会在<<合约验证>>部分详细了解。


公钥和私钥之间有着一种数学关系，这种数学关系可以使得私钥生成信息上的签名。这个签名可以根据公钥来验证真实性并可以防止泄露私钥。


使用以太的时候，当前的拥有者在每一笔交易中展示她的公钥以及签名（每一次都不一样，但是由同一个私钥产生）。在公钥以及签名的展示过程中，以太坊系统内的所有人都可以独自的验证并接受这笔交易为合法的，确认交易以太的人在交易当时为这些以太的拥有者。

[TIP]
====
((("秘钥与地址", "概述", "秘钥对")))在绝大部分钱包软件中，私钥以及公钥为了方便共同存储为_密钥对_。但是，公钥可以通过私钥很简单的推导出，所以只存储私钥也是可行的。
====

.为什么使用对称加密（公/私钥）？
****
((("加密", "对称")))((("数字签名", "对称加密与")))((("对称加密")))为什么在以太坊中使用对称加密？对称加密并不用来“加密”某笔交易。对称加密有用的特性是能够生成_数字签名_。一个私钥可以应用于一笔交易中的数字指纹来生成一个数字签名。这个签名可以只能由拥有私钥的人生成。然而，任何能够访问公钥以及交易指纹的人都可以使用签名来_验证_签名。对称加密的这个有用的特性使得任何人验证任何一笔交易中的签名成为可能，同时可以确保只有私钥的拥有者可以生成有效的签名。
****

[[private_keys]]
==== 私钥


((("秘钥与地址", "概述", "生成私钥")))((("警告与注意事项", "私钥保护")))一个私钥就是一串随机挑选数字。对私钥的拥有权以及控制是用户控制某个以太坊地址的所有资产根本所在，同时这个私钥也是保证用户拥有访问授权了地址的合约的权限。私钥，通过证明在交易过程中用到的资产的所有权，可以用来生成在使用以太过程中需要用到的签名。私钥在任何时刻都要保密，因为向第三方透露秘钥就等价于给予对方对这些以太资产以及合约的所有权。私钥一定要经过备份并且一定要妥善保管，因为如果将私钥丢失就不能被找回，并且与之关联的所有资产都会永久丢失。
[TIP]
====
以太坊的私钥只是一串数字。你可以通过任何方式随机生成你的私钥，例如硬币，铅笔以及纸：投掷一枚硬币２５６次之后你就拥有了一串可以在以太坊钱包中使用的２５６位的随机生成的二进制数字。公钥以及地址之后可以通过私钥产生。
====

===== 通过随机数生成私钥

生成秘钥的第一步，也是最重要的一步就是寻找一个安全的熵或者随机性的来源。生成一个以太坊的私钥等价于从１到2^256挑选数字。挑选数字的方法并不重要，只要方法是不可预测的并且不是重复的。以太坊软件使用的是底层操作系统的随机数生成器来生成２５６比特的熵（随机性）。通常来说，操作系统的随机数生成器由人初始化，这就是为什么你会被要求晃动几秒钟你的鼠标或者按一些键盘上的随机键位。

更准确的来说，可用的私钥会稍微比2^256少。私钥可以是+1+ and +n - 1+　中的任何一个数，其中ｎ是一个常数（n = 1.158 * 10^77^,　稍微小于　2^256^）定义为以太坊中椭圆曲线的阶数（参考<<椭圆曲线>>）。为了生成一个秘钥，我们随机挑选一个２５６比特的数字并且检查这个数字是否小于+n - 1+。　在编程的的术语中，通常通过输入一个更长的，从一个加密的，安全的随机信息源里，产生的数字到一个２５６位的例如Keccak-256或者SHA256算法里（参考<<加密_哈希_算法>>），　这种方式可以产生一个256比特的数字。如果结果小于 +n - 1+，　我们就得到了一个合适的私钥。否则我们会再次尝试。

[WARNING]
====
((("random numbers", "random number generation")))((("entropy", "random number generation")))Do not write your own code to create a random number or use a "simple" random number generator offered by your programming language. Use a cryptographically secure pseudo-random number generator (CSPRNG) with a seed from a source of sufficient entropy. Study the documentation of the random number generator library you choose to make sure it is cryptographically secure. Correct implementation of the CSPRNG is critical to the security of the keys.
====

The following is a randomly generated private key (k) shown in hexadecimal format (256 bits shown as 64 hexadecimal digits, each 4 bits):

----
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----


[TIP]
====
The size of Ethereum's private key space, (2^256^) is an unfathomably large number. It is approximately 10^77^ in decimal. For comparison, the visible universe is estimated to contain 10^80^ atoms.
====


[[pubkey]]
==== Public Keys

((("keys and addresses", "overview of", "public key calculation")))((("generator point")))An Ethereum public key is a _point_ on an elliptic curve, meaning it is a set of X and Y coordinates that satisfy the elliptic curve equation.

In simpler terms, an Ethereum public key is two numbers, joined together. These numbers are produced from the private key by a calculation that can _only go one way_. That means that it is trivial to calculate a public key if you have the private key. But you cannot calculate the private key from the public key.

[[WARNING]]
====
MATH is about to happen! Don't panic. If you find it hard to read the previous paragraph, you can skip the next few sections. There are many tools and libraries that will do the math for you.
====

The public key is calculated from the private key using elliptic curve multiplication, which is irreversible: _K_ = _k_ * _G_, where _k_ is the private key, _G_ is a constant point called the _generator point_, and _K_ is the resulting public key. The reverse operation, known as "finding the discrete logarithm"—calculating _k_ if you know _K_—is as difficult as trying all possible values of _k_, i.e., a brute-force search.

In simpler terms: arithmetic on the elliptic curve is different from "regular" integer arithmetic. A point (G) can be multiplied by an integer (k) to produce another point (K). But there is no such thing as _division_, so it is not possible to simply "divide" the public key K by the point G to calculate the private key k. This is the one-way mathematical function described in <<pkc>>.

[TIP]
====
Elliptic curve multiplication is a type of function that cryptographers call a "one way" function: it is easy to do in one direction (multiplication) and impossible to do in the reverse direction (division). The owner of the private key can easily create the public key and then share it with the world knowing that no one can reverse the function and calculate the private key from the public key. This mathematical trick becomes the basis for unforgeable and secure digital signatures that prove ownership of Ethereum funds and control of contracts.
====

Before we demonstrate how to generate a public key from a private key, let's look at elliptic curve cryptography in a bit more detail.


[[elliptic_curve]]
==== Elliptic Curve Cryptography Explained

((("keys and addresses", "overview of", "elliptic curve cryptography")))((("elliptic curve cryptography", id="eliptic04")))((("cryptography", "elliptic curve cryptography", id="Celliptic04")))Elliptic curve cryptography is a type of asymmetric or public key cryptography based on the discrete logarithm problem as expressed by addition and multiplication on the points of an elliptic curve.

<<ecc-curve>> is an example of an elliptic curve, similar to that used by Ethereum.

[TIP]
====
Ethereum uses the exact same elliptic curve, called +secp256k1+, as bitcoin. That makes it possible to re-use many of the elliptic curve libraries and tools from bitcoin.
====

[[ecc-curve]]
[role="smallerthirty"]
.A visualization of an elliptic curve
image::images/simple_elliptic_curve.png["ecc-curve"]

Ethereum uses a specific elliptic curve and set of mathematical constants, as defined in a standard called +secp256k1+, established by the National Institute of Standards and Technology (NIST). The +secp256k1+ curve is defined by the following function, which produces an elliptic curve:

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

or

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

The _mod p_ (modulo prime number p) indicates that this curve is over a finite field of prime order _p_, also written as latexmath:[\( \mathbb{F}_p \)], where p = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1, a very large prime number.

Because this curve is defined over a finite field of prime order instead of over the real numbers, it looks like a pattern of dots scattered in two dimensions, which makes it difficult to visualize. However, the math is identical to that of an elliptic curve over real numbers. As an example, <<ecc-over-F17-math>> shows the same elliptic curve over a much smaller finite field of prime order 17, showing a pattern of dots on a grid. The +secp256k1+ Ethereum elliptic curve can be thought of as a much more complex pattern of dots on a unfathomably large grid.

[[ecc-over-F17-math]]
[role="smallersixty"]
.Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17
image::images/ec_over_small_prime_field.png["ecc-over-F17-math"]

So, for example, the following is a point Q with coordinates (x,y) that is a point on the +secp256k1+ curve:

----
Q = (49790390825249384486033144355916864607616083520101638681403973749255924539515, 59574132161899900045862086493921015780032175291755807399284007721050341297360)
----

<<example_1>> shows how you can check this yourself using Python. The variables x and y are the coordinates of the point Q as above. The variable p is the prime order of the elliptic curve (the prime that is used for all the modulo operations). The last line of Python is the elliptic curve equation (the % operator in Python is the modulo operator). If x and y are indeed points on the elliptic curve, then they satisfy the equation and the result is zero (+0L+ is a long integer with value zero). Try it yourself, by typing +python+ on a command line and copying each line (after the prompt +>>>+) from the listing:

[[example_1]]
.Using Python to confirm that this point is on the elliptic curve
====
[source, pycon]
----
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
>>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
>>> (x ** 3 + 7 - y**2) % p
0L
----
====

[[ec_math]]
==== 椭圆曲线算术运算

很多椭圆曲线数学看起来很像我们在学校学到的整数算术。具体而言，我们可以定义一个加法运算符，而不是添加数字就是在曲线上添加点。一旦我们有了加法运算符，我们也可以定义一个点和一个整数的乘法，这样它就等于重复加法。

加法被定义为使得给定椭圆曲线上的两个点P 1和P 2，在椭圆曲线上也存在第三点P 3 = P 1 + P 2。

在几何上，通过在P 1和P 2之间划一条线来计算该第三点P 3。这条线将在另外一个地方与椭圆曲线相交。称此点P 3 '=（x，y）。然后在x轴上反射以得到P 3 =（x，-y）。

在椭圆曲线数学中，有一个叫做“无穷远点”的点，它大致对应于零点的作用。在计算机上，它有时用x = y = 0表示（它不满足椭圆曲线方程，但它是一个可以检查,很容易分开的情况）。有几个特殊情况解释了“无限点”的必要条件。

如果P 1和P 2是相同的点，则在P 1和P 2之间的线应当延伸成在该点P 1处的曲线上的切线。该切线恰好与一条新点中的曲线相交。您可以使用微积分技术来确定切线的斜率。尽管我们将我们的兴趣局限在具有两个整数坐标的曲线上，但这些技巧仍然令人好奇地工作！

在某些情况下（即如果P 1和P 2具有相同的x值但不同的y值），切线将完全垂直，在这种情况下，P3 =“无限点”。

如果P 1是“无穷远点”，则P 1 + P 2 = P 2。类似地，如果P 2是无穷远处的点，则P 1 + P 2 = P 1。这显示了无限的点如何扮演零在“正常”算术中扮演的角色。

事实证明+是关联的，这意味着（A + B）+ C = A +（B + C）。这意味着我们可以在没有括号的情况下写出A + B + C而没有歧义。

现在我们已经定义了加法，我们可以用扩展加法的标准方式来定义乘法。对于椭圆曲线上的点P，如果k是整数，则k * P = P + P + P + ... + P（k次）。请注意，在这种情况下，k有时会被混淆地称为“指数”

[[public_key_derivation]]
==== 生成公钥

((("keys and addresses", "overview of", "public key generation")))((("generator point")))在随机生成的数字形式的私有密钥开始ķ，我们通过称为曲线上的预定点相乘发生器点 ģ到别的地方产生的曲线，这是对应的公共密钥上的另一点ķ。发生器点被指定为secp256k1标准的一部分，并且对于secp256k1的所有实现始终相同，并且从该曲线派生的所有密钥都使用相同的点G：

[latexmath]
++++
\begin{equation}
{K = k * G}
\end{equation}
++++

其中k是私钥，G是生成器点，K是结果公钥，即曲线上的一个点。由于发电机点总是对所有用户的复仇一样，私钥ķ乘以摹总是会产生相同的公钥ķ。之间的关系ķ和ķ是固定的，但只能在一个方向上进行计算，从ķ到ķ。这就是为什么Ethereum地址（从K派生）可以与任何人共享并且不会泄露用户的私钥（k）的原因。

正如我们在椭圆曲线算术运算中所描述的那样，k * G的乘法相当于重复加法，所以G + G + G + ... + G重复k次。总之，为了生成公钥ķ，从一个私有密钥ķ，我们的发电机点加摹本身，ķ倍。

[提示]
====
私钥可以转换为公钥，但公钥不能转换回私钥，因为数学只能用一种方法。
====

让我们用这个计算找到特定的我们展示给你私钥的公钥：


[[example_privkey]]
.公钥计算的私钥示例
----
K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G
----

密码库可以帮助我们使用椭圆曲线乘法计算K值。得到的公钥K被定义为点K =（x，y）：

[[example_pubkey]]
.从示例私钥计算的示例公钥
----
K = (x, y)

这里,

x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

在以太坊中，您可以看到公钥以66个十六进制字符（33字节）的十六进制序列表示。这是行业联盟标准高效密码组（SECG）提出的标准序列化格式中采用的，记录在高效密码标准（SEC1）中。该标准定义了四个可用于识别椭圆曲线上点的可能前缀：

|===
| 字首 | 含义 | 长度（字节计数前缀） |
|0x00| 指向无限 | 1 |
|0x04| 未压缩的点 | 65 |
|0x02| 接近Y的压缩点 | 33 |
|0x03| 奇数Y的压缩点 | 33 |
|===

以太坊只使用未压缩的公钥，因此唯一相关的前缀是（十六进制）04。序列化连接公钥的X和Y坐标：

----
04 + X坐标（32字节/ 64十六进制）+ Y坐标（32字节/ 64十六进制）
----

因此，我们在示例私钥计算的示例公钥中计算的公钥被序列化为：

----
046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

==== 椭圆曲线库

加密货币相关项目中使用了secp256k1椭圆曲线的几个实现：

((("OpenSSL cryptographic library")))OpenSSL:: TOpenSSL库提供了一套全面的加密原语，包括secp256k1的完整实现。例如，要派生公钥，可以使用函数EC_POINT_mul（）. 在这里可以找到https://www.openssl.org/

((("libsecp256k1 cryptographic library")))libsecp256k1:: Bitcoin Core的libsecp256k1是secp256k1椭圆曲线和其他加密基元的C语言实现。椭圆曲线密码学的libsecp256是用scratch编写的，代替了比特币核心软件中的OpenSSL，在性能和安全性方面被认为是优越的。在https://github.com/bitcoin-core/secp256k1找到它

[[hash_functions]]
=== 加密哈希函数

((("hash function")))密码哈希函数在整个以太坊使用。实际上，散列函数在几乎所有的密码系统中都有广泛的应用，这是密码学家布鲁斯•施奈尔（Bruce Schneier）所说的一个事实，他说：“相比加密算法，单向散列函数是现代密码学的主要工具。”

在本节中，我们将讨论散列函数，了解它们的基本属性以及这些属性如何使它们在现代密码学的很多领域如此有用。我们在这里讨论哈希函数，因为它们是将以太坊公钥转换为地址的一部分。

简而言之，“散列函数是可用于将任意大小的数据映射到固定大小的数据的任意函数。” 来源：维基百科。散列函数的输入称为前映像或消息。输出被称为散列或摘要。哈希函数的一个特殊子类别是加密哈希函数，它具有对密码学有用的特定属性。

密码散列函数是一种单向散列函数，它将任意大小的数据映射到固定大小的位串，如果知道输出，则在计算上不可能重新创建输入。确定输入的唯一方法是对可能的输入进行暴力搜索，检查匹配输出。

加密哈希函数有五个主要属性（来源：维基百科/加密哈希函数）：

确定性:: 任何输入消息总是产生相同的散列摘要。

可验证:: 计算消息的散列是有效的（线性性能）。

不可逆性（抵抗第一张预映像）:: 从哈希计算消息是不可行的，相当于通过可能的消息进行暴力搜索。

不相关:: 对消息的小改动（例如，一bit的改变）应该如此广泛地改变散列输出，以至于它不能与原始消息的散列相关联。

碰撞保护（抵抗第二张前像:: 计算产生相同散列输出的两个不同消息应该是不可行的。

这些属性的组合使加密散列函数可用于广泛的安全应用程序，包括：

* 数据指纹
* 消息完整性（错误检测）
* 验证的工作
* 身份验证（密码散列和密钥扩展）
* 伪随机数发生器
* 预映像承诺
* 唯一标识符

在我们通过系统的各个层面进行研究时，我们会在以太坊找到其中的很多。

==== 以太坊的加密哈希函数 - Keccak-256

((("SHA-3 Hash Function")))((("Keccak Hash Function")))((("Keccak-256")))以太坊在许多地方使用Keccak-256密码散列函数。Keccak-256被设计为国家科学和技术研究院（NIST）于2007年举行的SHA-3密码散列函数竞赛的候选人。Keccak在2015年成为标准化为联邦信息处理标准（FIPS）202的获奖算法。

然而，在Ethereum开发期间，NIST标准化工作正在完成。在标准过程完成后，NIST调整了Keccak的一些参数，据称可以提高效率。这与英雄举报人爱德华斯诺登透露的文件暗示NIST可能受到国家安全局的不当影响，故意削弱Dual_EC_DRBG随机数生成器标准，在标准随机数生成器中有效地设置后门的同时发生。这场争论的结果是反对所提议修改以及严重拖延了SHA-3标准化。当时，以太坊基金会决定实施原来的Keccak算法，正如其发明人所提议的那样，

[警告]
====
虽然您可能在Ethereum文档和代码中看到“SHA3”，但很多（可能不是全部）这些实例实际上是指Keccak-256，而不是最终确定的FIPS-202 SHA-3标准。实现差异很小，与填充参数有关，但它们的重要性在于Keccak-256在给定相同输入的情况下产生与FIPS-202 SHA-3不同的散列输出。
====

由于以太坊（Keccak-256）中使用的散列函数与最终标准（FIP-202 SHA-3）之间的差异所导致的混乱，因此(开发人员？)正在努力在所有代码，操作码和库中重命名所有sha3实例到keccak256。详情请参阅ERC-59。

==== 我使用的是哪种散列函数

如何判断您使用的软件库是FIPS-202 SHA-3还是Keccak-256（如果两者都可能被称为“SHA3”）？

一个简单的方法是使用测试矢量，一个给定输入的预期输出。最常用于散列函数的测试是空输入。如果您使用空字符串作为输入运行散列函数，您应该看到以下结果：

[[sha3_test_vectors]]
.测试您使用的SHA3库是否是FIP-202 SHA-3的Keccak-256
----
Keccak-256("") =
c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

SHA-3("") =
a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
----

因此，无论调用什么函数，都可以通过运行上面的简单测试来测试它是否是原始的Keccak-256或最终的NIST标准FIPS-202 SHA-3。请记住，以太坊使用Keccak-256，尽管它在代码中通常被称为SHA-3。

接下来，我们来研究一下Ethereum中Keccak-256的第一个应用，它将从公钥生成以太坊地址。

=== 以太坊地址

以太坊地址是使用单向散列函数（特别是Keccak-256）从公钥或合约派生的唯一标识符。

在我们之前的例子中，我们从一个私钥开始，并使用椭圆曲线乘法来派生一个公钥：

私钥k：
----
k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
----

公钥K（X和Y坐标连接并显示为十六进制）：
----
K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

我们使用Keccak-256来计算这个公钥的哈希值：

----
Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

然后我们只保留最后的20个字节，这是我们的以太坊地址：

----
001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

大多数情况下，您会看到带有前缀“0x”的以太坊地址，表明它是十六进制编码，如下所示：

----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

=== 以太坊的地址格式

Ethereum addresses are hexadecimal numbers, identifiers derived from the last 20 bytes of the Keccak-256 hash of the public key.
以太坊地址是一串十六进制数字，取公钥的Keccak-256哈希值的最后20个字节。

Unlike bitcoin addresses which are encoded in the user interface of all clients to include a built-in checksum to protect against mistyped addresses, Ethereum addresses are presented as raw hexadecimal without any checksum.
比特币是在客户端的用户界面中编码地址，包含内置校验和，进而防止输入错误的地址，而以太坊地址以原始十六进制形式呈现，没有经过任何校验和。

The rationale behind that decision was that Ethereum addresses would eventually be hidden behind abstractions (such as name services) at higher layers of the system and that checksums should be added at higher layers if necessary.
该协议其中的基本原理是，以太坊地址最终会隐藏在系统高层的抽象（如命名服务）之后，并且必要时应在较高层添加校验和。

In retrospect, this design choice lead to a number of problems, including the loss of funds due to mistyped addresses and input validation errors. Ethereum name services were developed slower than initially expected and alternative encodings such as ICAP were adopted very slowly by wallet developers.
深思起来，这种设计选择会带来一些问题一些问题，包括由于输入错误地址和输入验证错误而导致的资金损失。 以太坊命名服务的开发速度低于最初预期，再诸如ICAP之类的替代编码被钱包开发商采纳的速度非常缓慢。
互通客户端地址协议（ICAP）


==== Inter exchange Client Address Protocol (ICAP) 互通客户端地址协议（ICAP）

The _Inter exchange Client Address Protocol (ICAP)_ is an Ethereum Address encoding that is partly compatible with the International Bank Account Number (IBAN) encoding, offering a versatile, checksummed and interoperable encoding for Ethereum Addresses. ICAP addresses can encode Ethereum Addresses or common names registered with an Ethereum name registry.
客户端地址互换协议（ICAP）是一种与国际银行帐号（IBAN）编码部分兼容的以太坊地址编码，进而以太坊地址提供多功能，校验和相互操作编码。 ICAP地址可以编码以太坊地址或通过以太坊名称注册表注册的常用名称

Read about ICAP on the Ethereum Wiki:https://github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol
以太坊Wiki上的ICAP原文：https://github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol

IBAN is an international standard for identifying bank account numbers, mostly used for wire transfers. It is broadly adopted in the European Single Euro Payments Area (SEPA) and beyond. IBAN is a centralized and heavily regulated service. ICAP is a decentralized but compatible implementation for Ethereum addresses.
IBAN是识别银行账号的一种国际标准，主要应用于电汇。 它在单一欧元支付区（SEPA）中被广泛采用。 IBAN是一项集中且严格监管的服务。 对以太坊地址来说，ICAP可以实现以太坊地址的分散和兼容性。

An IBAN consists of up to 34 alphanumeric characters (case-insensitive) string containing a country code, checksum, and bank account identifier (which is country-specific).
一个IBAN由34个以上的国家代码，校验和以及银行账户标识符（特定国家）的字母数字字符（不区分大小写）组成。

ICAP uses the same structure by introducing a non-standard country code "XE" that stands for "Ethereum", followed by a two character checksum and 3 possible variations of an account identifier:
ICAP采用相同的结构，引入代表"Ethereum"的非标准国家代码"XE"，后面跟着两个字符的校验和以及3个可能的账户标识符变体：

Direct:: Up to 30 alphanumeric character big-endian base-36 integer representing the least significant bits of an Ethereum address. Because this encoding fits less than 155 bits, it only works for Ethereum addresses that start with one or more zero bytes. The advantage is that it is compatible with IBAN, in terms of the field length and checksum. Example: +XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD+ (33 characters long)
Direct:: 多达30个字母数字字符big-endian base-36整数，表示以太坊地址的最低有效位。 由于此编码适合小于155位，因此它仅适用于以一个或多个零字节开头的以太坊地址。 就字段长度和校验和而言，其优点是它能与IBAN兼容。 示例：+XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD+（33个字符长）

Basic:: Same as the "Direct" encoding except that it is 31 characters long. This allows it to encode any Ethereum address, but makes it incompatible with IBAN field validation. Example: +XE18CHDJBPLTBCJ03FE9 O2NS0BPOJVQCU2P+ (35 characters long)
Basic:: 除长度为31个字符外，与"Direct"编码相同。 这使得它可以编码任何以太坊地址，却和BAN字段验证并不兼容。 示例：+XE18CHDJBPLTBCJ03FE9 O2NS0BPOJVQCU2P+（35个字符长）

Indirect:: Encodes an identifier that resolves to an Ethereum address through a name registry provider. Uses 16 alphanumeric characters, composed of an _asset identifier_ (e.g. ETH), a name service (e.g. XREG) and a 9 character name (e.g. KITTYCATS), which is a human readable name. Example: +XEpass:[##]ETHXREGKITTYCATS+ (20 characters long), where the "##" should be replaced by the two computed checksum characters.
Indirect:: 编码一个标识符, 它通过名称注册表提供去解析以太坊地址。利用16个字母数字字符，其中包含资产标识符（例如ETH），名称服务（例如XREG）和9字符名称（例如KITTYCATS），这是一个人类可以直接阅读的名称。 示例：+XEpass:[##]ETHXREGKITTYCATS+（20个字符长），"##"代表两个计算校验和字符。

We can use the +helpeth+ command-line tool to create ICAP addresses. Let's try with our example private key (prefixed with 0x and passed as a parameter to helpeth):
我们可以使用+helpeth+命令行工具来创建ICAP地址。 我们可以尝试使用私钥示例（前缀为0x并作为参数传递给helpeth）：

----
$ helpeth keyDetails -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315

Address: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
ICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D
Public key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
----

The +helpeth+ command constructs a hexadecimal Ethereum address as well as an ICAP address for us. The ICAP address for our example key is:
+helpeth+命令为我们构造了一个十六进制以太坊地址和一个ICAP地址。 我们示例密钥的ICAP地址是：

----
XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD
----

Because our example Ethereum address happens to start with a zero byte, it can be encoded using the "Direct" ICAP encoding method that is a valid in an IBAN format. You can tell because it is 33 characters long.
由于我们的示例以太坊地址恰好以零字节开始，因此可以使用在IBAN格式中有效的"直接"ICAP编码方法进行编码。 你可以自行判断，因为它是33个字符长。

If our address did not start with a zero, it would be encoded with the "Basic" encoding, which would be 35 characters long and invalid as an IBAN format.
如果我们的地址不是从零开始，那么它将被编码为"Basic"编码，也就是35个字符长，同时作为IBAN格式是无效。

[TIP]
====
The chances of any Ethereum address starting with a zero byte are 1 in 256. To generate one like that, it will take on average 256 attempts with 256 different random private keys before we find one that works as an IBAN-compatible "Direct" encoded ICAP address.
以零字节开始的任何以太坊地址的概率是1：256. 要生成这样一个类型的地址，在找到一个作为IBAN兼容的"直接"编码ICAP地址之前，它将利用平均256个不同的随机私钥进行256次尝试。
====

At this time, ICAP is unfortunately only supported by a few wallets.
如果是这样的话，仅会有极少数的钱包支持ICAP。

==== Hex Encoding with Checksum in Capitalization (EIP-55) 十六进制编码大小写字母的校验和（EIP-55）

Due to the slow deployment of ICAP or name services, a new standard was proposed with Ethereum Improvement Proposal 55 (EIP-55). You can read the details at:
由于ICAP或命名服 务调度缓慢，因此提出了一个新的标准，采用以太坊改进建议-55（EIP-55）。以下链接提供详细信息：

https://github.com/Ethereum/EIPs/blob/master/EIPS/eip-55.md

EIP-55 offers a backwards compatible checksum for Ethereum addresses by modifying the capitalization of the hexadecimal address. The idea is that Ethereum addresses are case-insensitive and all wallets are supposed to accept Ethereum addresses expressed in capital or lower-case characters, without any difference in interpretation.
通过修改十六进制地址的大小写，EIP-55为以太坊地址提供向后兼容的校验和。具体想法如下，以太坊地址不区分大小写，所有钱包都应该接受以大写字母或小写字母表示的以太坊地址，在解释上不存在任何区别。

By modifying the capitalization of the alphabetic characters in the address, we can convey a checksum that can be used to protect the integrity of the address against typing or reading mistakes. Wallets that do not support EIP-55 checksums simply ignore the fact that the address contains mixed capitalization. But those that do support it, can validate it and detect errors with a 99.986% accuracy.
通过修改地址中字母字符的大小写，我们可以传达一个校验和，用来保护地址的完整性，避免输入或读取错误。不支持EIP-55校验和的钱包粗略地忽略地址包含混合大写的事实。但那些支持EIP-55校验和的钱包可以验证，还能以99.986％的准确度检测存在的错误。

The mixed-capitals encoding is subtle and you may not notice it at first. Our example address is:
混合大写字母的编码变化很微妙，最初你甚至不会注意到它。 我们的示例地址是：

----
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
----

with an EIP-55 mixed-capitalization checksum it becomes:
通过EIP-55混合大写校验和，它变成：

----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

Can you tell the difference? Some of the alphabetic (A-F) characters from the hexadecimal encoding alphabet are now capital, while others are lower case. You might not even notice the difference, unless you looked carefully.
你能分辨出来吗？ 一些来自十六进制编码字母的字母（A-F）字符现在是大写字母，而另一些则是小写字母。 除非你仔细观察，否则你甚至不会注意到这种差异的存在。

EIP-55 is quite simple to implement. We take the Keccak-256 hash of the lower-case hexadecimal address. This hash acts as a digital fingerprint of the address, giving us a convenient checksum. Any small change in the input (the address) should cause a big change in the resulting hash (the checksum), allowing us to detect errors effectively. The hash of our address is then encoded in the capitalization of the address itself. Let's break it down, step-by-step:
EIP-55实施起来十分的简单。 我们采用小写十六进制地址的Keccak-256哈希。 这个哈希值作为该地址的数字指纹，为我们提供了一个bian'jie的校验和。 输入（地址）中的任何小改动都会导致哈希值结果（校验和）发生很大变动，从而使我们能够有效地检测存在的错误。 然后我们的地址的哈希值被编码为地址中的大写字母。 我们可以以一步步解析它：

1. Hash the lower-case address, without the +0x+ prefix:
哈希小写地址，不带+0x+前缀：

----
Keccak-256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9")
23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1
----

[start=2]
1. Capitalize each alphabetic address character if the corresponding hex digit of the hash is greater than or equal to +0x8+. This is easier to show if we line up the address and the hash:
如果哈希值的相应十六进制数字大于或等于0x8，则将每个字母地址字符大写。 如果我们排列地址和哈希，这将更容易显示：

----
Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

Our address contains an alphabetic character +d+ in the fourth position. The fourth character of the hash is +6+, which is less than +8+. So, we leave the +d+ lower-case. The next alphabetic character in our address is +f+, in the sixth position. The sixth character of the hexadecimal hash is +c+, which is greater than +8+. Therefore, we capitalize the +F+ in the address, and so on. As you can see, we only use the first 20-bytes (40 hex characters) of the hash as a checksum, since we only have 20-bytes (40 hex characters) in the address to capitalize appropriately.
地址的第四个位置上是字母d。 哈希值的第四个字符是6，它小于8.所以，我们忽略小写字母d。 我们地址中的下一个字母字符是f，在第六位。 十六进制散列的第六个字符是c，它大于8.因此，我们在地址中大写了F，依此类推。 正如您所看到的，我们只使用哈希值的前20个字节（40个十六进制字符）作为校验和，因为我们只有20个字节（40个十六进制字符）能被相应地改为大写。

Check the resulting mixed-capitals address yourself and see if you can tell which characters were capitalized and which characters they correspond to in the address hash:
检查自己生成的混合大写地址，看看您是否可以判断出哪些字符，以及它们对应的哈希值中的字符：

----
Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
----

==== Detecting an error in an EIP-55 encoded address 检测EIP-55编码地址中的错误

Now, let's look at how EIP-55 addresses will help us find an error. Let's assume we have printed out an Ethereum address, which is EIP-55 encoded:
现在，我们来看看EIP-55地址如何帮助我们发现错误。 假设我们已经打印出ETHER-E编码的以太坊地址：

----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
----

Now let's make a basic mistake in reading that address. The character before the last one is a capital "F". For this example let's assume we misread that as a capital "E". We type in the (incorrect address) into our wallet:
现在，我们故意犯下一个阅读该地址时的基本错误。 最后一个字符之前的字符是大写字母"F"。 对于这个例子，我们假设我们误解为大写"E"。 我们在钱包中输入（不正确的地址）：

----
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
----

Fortunately, our wallet is EIP-55 compliant! It notices the mixed capitalization and attempts to validate the address. It converts it to lower case, and calculates the checksum hash:
幸运的是，我们的钱包符合EIP-55标准！ 它注意到混合大写字母进而尝试验证地址。 它将其转换为小写，并计算校验和哈希值：

----
Keccak-256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9")
5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927
----

As you can see, even though the address has only changed by one character (in fact, only one bit as "e" and "f" are 1-bit apart), the hash of the address has changed radically. That's the property of hash functions that makes them so useful for checksums!
正如你所看到的，尽管地址只改变了一个字符（事实上，只有一位"e"和"f"相隔了1字符间距），地址的哈希值却发生根本性的改变。 这就是哈希值函数的特性，使得它们对校验和非常有帮助！

Now, let's line up the two and check the capitalization:
现在，让我们排列这两个地址并检查大小写：

----
001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
5429b5d9460122fb4b11af9cb88b7bb76d892886...
----

It's all wrong! Several of the alphabetic characters are incorrectly capitalized. Now remember, the capitalization is the encoding of the _correct_ checksum.
这俩都是错误的！ 其中的几个字母字符被错误的大写了。 现在请记住，大写字母是正确校验和的编码。

The capitalization of the address we input doesn't match the checksum just calculated, meaning something has changed in the address, some error has been introduced.
我们输入的地址大小写与刚刚计算的校验和不匹配，这就意味着地址中的内容发生了变化，并引入了一些错误。
