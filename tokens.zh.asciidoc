
=== 代币标准

在以太坊之前区块链代币就已经存在. 某种意义上来说, 首个区块链货币-比特币本身也是代币。在以太坊之前，也曾开发出很多基于比特币和其他加密货币的代币平台。然而，以太坊首次引入的代币标准引爆了代币规模。

Vitalik Buterin提议代币作为诸如以太坊这类通用编程区块链的最显著和有用的应用之一。实际上，在以太坊诞生的第一年，经常能看到Vitalik和别人穿着背面印有以太坊logo和一小段智能合约代码示例的T恤啥。T恤衫样式多种多样，但是最相似的地方是都展示一段token实现的代码。

==== ERC20 代币标准

Fabian Vogelsteller在2015年9月提出首个标准，作为以太坊请求合并提议（ERC）。它被github自动编号为20号提议，这就是“ERC20代币”名称的由来。目前大部分代币基于ERC20。ERC20合并请求，最终成为以太坊改进提议20（EIP20），但是大家仍旧用它原来的名字ERC20。你可以通过下面链接了解这个标准:

https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md

ERC20是为_代币_提出的标准，这就意味着不同种类的ERC20代币可以互相取代，而且每种代币并没有什么特殊的地方。
ERC20标准为实现代币的合约定义了相同的接口，因此任一兼容的代币都可以用相同的方式获取和使用。接口除包含一些在基于ERC20标准开发的时候必须实现的函数外，还有一些由开发者自己决定的可选函数和属性。

===== ERC20 必须实现的函数&事件

totalSupply函数:: 返回代币现有的总数,ERC20代币的总数可以是固定的或者可变的。

balanceOf函数:: 输入一个地址，返回该地址的代币余额。

transfer函数:: 输入一个地址和一定数额, 从执行transfer函数的地址余额中转到该地址该数量代币。

transferFrom函数:: 输入一个发送者，接收者和数额,从一个账户里转账代币到另一个账户。跟下面的+approve+函数一起使用。

approve函数:: 输入接收者地址和数额，授权那个地址从发起批准指令的账户中执行若干次转账直到达到数额要求。

allowance函数:: 输入所有者地址和消费者地址，返回消费者能从所有者取走的余额。

Transfer事件:: 成功执行transfer指令后触发的事件(调用+transfer+函数或者+transferFrom+函数) (即使转账0也会触发).

Approval事件:: 成功调用+approve+函数后记录的事件。

===== ERC20可选实现的函数

name函数:: 返回一个该代币的易读名字（例如美元）

symbol函数:: 返回一个该代币的易读代号（例如USD）

decimals函数:: 返回用于分割代币数量的精度。譬如假如精度是2,那么呈现在用户面前的是被100整除后的代币数量。

===== Solidity中定义的ERC20标准

下面就是ERC20接口标准在Solidity中的样子:

----
contract ERC20 {
   function totalSupply() constant returns (uint theTotalSupply);
   function balanceOf(address _owner) constant returns (uint balance);
   function transfer(address _to, uint _value) returns (bool success);
   function transferFrom(address _from, address _to, uint _value) returns (bool success);
   function approve(address _spender, uint _value) returns (bool success);
   function allowance(address _owner, address _spender) constant returns (uint remaining);
   event Transfer(address indexed _from, address indexed _to, uint _value);
   event Approval(address indexed _owner, address indexed _spender, uint _value);
}
----

===== ERC20数据结构

如果你去看任何ERC20的实现方式，都会包含两种数据结构，一种用于追踪余额，另一个用于追踪限额。在Solidity中，他们使用_数据映射_来实现。 

第一个数据映射实现用户代币余额的初始表，它允许代币合约追踪谁持有代币。每笔转账就是一次一个账户余额的减少和另个账户余额的增加。

.余额: 从地址（所有者）到账目（余额）的一次映射
----
mapping(address => uint256) balances;
----

第二类数据结构是限额的一次数据映射，正如我们即将在<<transfer_workflows>>所见,使用ERC20代币的时候，代币所有者可以授权给消费者，允许他们从所有者余额中花特定数（限额）目。ERC20合约使用一个二维的映射追踪限额，主键是所有者的地址，映射到消费者地址和限额额度。

.限额: 一次从地址（所有者）到地址（消费者）到额度（限额）的映射
----
mapping (address => mapping (address => uint256)) public allowed;
----


[[transfer_workflows]]
===== ERC20工作流: "transfer" 和 "approve & transferFrom"

ERC20代币有两个传输函数，你可能会疑惑为什么要这样。

ERC20允许两种不同的工作流。第一种是单向交易，使用transfer函数的直接工作流。这种工作流用于一些钱包发给其他钱包代币。大部分代币交易以这种+传输+流程产生。

执行这种转账合约很简单。如果Alice想给Bob发送10枚代币，她的钱包发送一个交易指令到代币合约地址，调用transfer函数，以Bob的地址和10作为参数。代币合约调整Alice的余额（-10）和Bob的余额（+10）以及触发一个transfer事件。

第二种工作流程是一个使用approve和transferFrom函数的双向交易流。这种工作流允许代币持有者委托他们的权限给另外一个地址。经常用于委托权限给一个用于分发代币的合约，不过也可以用于交易。例如，加入一家公司正在销售代币来ICO，他们可以授权给一个crowdsale合约地址来分发一定数量的代币。crowdsale合约然后可以把代币合约所有者的余额转给每一个该代币的购买者。

[[approve_transferFrom_workflow]]
.ERC20代币两步授权和转账流程图
image::images/approve_transferFrom_workflow.png["The two-step approve & transferFrom workflow of ERC20 tokens"]

对于授权和转账工作流，需要两笔交易。举例说Alice想要允许AliceICO合约销售所有AliceCoin代币的50%给像Bob和Charlie这样的买家。首先，Alice开发AliceCoin ERC20合约，发布所有AliceCoin到她自己的地址。然后，Alice开发可以销售代币换取以太币的AliceICO合约。接下来，Alice初始化授权和转账工作流。她发送交易指令给AliceCoin，调用approve函数，入参为AliceICO地址和50%总量。这将触发授权事件。现在AliceICO合约就能出售AliceCoin。当AliceICO收到来自Bob的以太币，它需要给Bob回送一些。为实现回送，AliceICO调用AliceCoin transferFrom函数，以Alice的地址作为发送方，Bob的地址作为接收放以及会送给Bob的代币额度。AliceCoin合约从Alice的地址转余额到Bob的地址，触发一个Transfer事件。AliceICO合约可以无限次调用transferFrom函数，只要它没有超过Alice设置的授权上限。AliceICO合约可以通过调用限额函数追踪出售了多少AliceCoin代币。

===== ERC20 实现

虽然有可能通过大约30行Solidity代码实现ERC20兼容性代币，考虑到潜在的安全脆弱性问题大部分实现方式非常复杂。EIP20标准提到了两种实现方式：

Consensys EIP20:: 一种简单并且易读的ERC20兼容性代币实现方式。

你可以从下面链接查看Consenys实现方式的Solidity代码:
https://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20.sol

OpenZeppelin StandardToken:: 这种实现方式是具有额外安全预防的ERC20兼容性代币。OpenZeppelin库由实现更复杂的具有融资、拍卖、行权计划和其他特性的ERC-20代币组成

你可以从下面链接查看OpenZeppelin标准代币实现方式的Solidity代码:
https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol

[[metoken_example]]
==== 发行我们自己的ERC20代币

让我们创造并发现我们自己的代币。以此为例，我们将使用truffle框架（查看 <<truffle>>）。本示例认为你已经安装了truffle，配置好了环境，并且熟悉它的基本操作。

我们给自己的代币起名为“精通以太坊代币”，代号“MEI”。

你可以在本书的仓库里找到该示例：
https://github.com/ethereumbook/ethereumbook/blob/first_edition/code/METoken

首先，让我们新建并且初始化一个truffle项目文件夹，跟在<<truffle_project_directory>>中一样。运行以下四条指令，对任意问题都选择默认答案。:

----
$ mkdir METoken
$ cd METoken
METoken $ truffle init
METoken $ npm init
----

你应该有如下所示的文件夹结构:

----
METoken/
├── contracts
│   └── Migrations.sol
├── migrations
│   └── 1_initial_migration.js
├── package.json
├── test
├── truffle-config.js
└── truffle.js
----

编辑+truffle.js+配置文件，设置你的truffle环境，或者复制我们用过的：

https://github.com/ethereumbook/ethereumbook/blob/first_edition/code/Faucet/truffle.js

如果你使用示例中的+truffle.js+文件，记得在METoken文件夹创建一个包含测试私钥的.env文件，该私钥用于在像ganache或者Kovan这样的公共以太坊测试网络上进行测试和部署。你可以从MetaMask导出自己的测试网络私钥。

[提醒]
====
只能使用测试用私钥或者测试用助记词，要确保这些并没有应用在以太坊主网持有资金，绝对不要使用持有真实钱财的密钥来测试。Only use test keys or test mnemonics that are not used to hold funds on the main Ethereum network. Never use keys that hold real money for testing.
====

示例中引用OpenZeppelin标准合约，该方式实现了某些重要的安全校验功能，并且易于扩展。让我们引用这个库：

----
$ npm install zeppelin-solidity

+ zeppelin-solidity@1.6.0
added 8 packages in 2.504s
----

+zeppelin-solidity+包将会在+node_modules+文件夹下增加大约250个文件。OpenZeppelin除ERC20代币外还包含很多东西，但是我们只用它的一小部分功能。

接下来，让我们编写我们的代币合约。创建一个名为+METoken.sol+的新文件，然后从Github中拷贝示例代码：

https://github.com/ethereumbook/ethereumbook/blob/first_edition/code/METoken/contracts/METoken.sol

我们的合约非常简单，因为它继承了OpenZeppelin StandardToken库中的所有功能:

[[solidity_token_example]]
.METoken.sol : A Solidity contract implementing an ERC20 token
[source,solidity,linenums]
----
include::code/METoken/contracts/METoken.sol[]
----

这里，我们定义可选变量如名字、代号和精度。我们还定义了一个初始量变量，设为2100万枚，以及H两位精度的细分（总共21亿）。在合约的初始化函数（构造函数）我们设置总量等于初始量并且分配所有的初始量到创建+METoken+合约的账户（+msg.sender+）余额中。

现在我们使用truffle来编译+METoken+代码:

----
$ truffle compile
Compiling ./contracts/METoken.sol...
Compiling ./contracts/Migrations.sol...
Compiling zeppelin-solidity/contracts/math/SafeMath.sol...
Compiling zeppelin-solidity/contracts/token/ERC20/BasicToken.sol...
Compiling zeppelin-solidity/contracts/token/ERC20/ERC20.sol...
Compiling zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol...
Compiling zeppelin-solidity/contracts/token/ERC20/StandardToken.sol...

----

如你所见，+truffle+从OpenZeppelin提取了必需的依赖文件并且也编译这些合约。

让我们设置一个移动脚本来部署+METoken+合约。在+METoken/migrations+文件夹下创建一个名为+2_deploy_contracts.js+的新文件。从下面链接的Github仓库中复制内容:

https://github.com/ethereumbook/ethereumbook/blob/first_edition/code/METoken/migrations/2_deploy_contracts.js

下面是它里面的代码：

[[metoken_migration]]
.2_deploy_contracts: Migration to deploy METoken
[source,javascript,linenums]
----
include::code/METoken/migrations/2_deploy_contracts.js[]
----

在我们部署在某个以太坊测试网络之前，让我们启动一个本地区块链测试一下。可以使用+ganache+命令行或者从可视化界面启动+ganache+区块链，如我们在<<using_ganache>>所做的一样。

一旦+ganache+启动，我们就可以部署我们的METoken合约来看看是否一切运行正常：

----
$ truffle migrate --network ganache
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb2e90a056dc6ad8e654683921fc613c796a03b89df6760ec1db1084ea4a084eb
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying METoken...
  ... 0xbe9290d59678b412e60ed6aefedb17364f4ad2977cfb2076b9b8ad415c5dc9f0
  METoken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...

----

在+ganache+控制台,我们应该能看到我们的部署已经创建了四笔新交易:

[[ganache_metoken]]
.METoken deployment on Ganache
image::images/ganache_metoken.png["METoken deployment on Ganache"]

